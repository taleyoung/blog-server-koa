2020-01-06 14:54 +08:00: koa-api server listening on 8080
2020-01-06 15:40 +08:00: server-koa server listening on 8080
2020-01-06 15:40 +08:00:   <-- GET /api/v1/article/138
2020-01-06 15:40 +08:00: data {
2020-01-06 15:40 +08:00:   id: 138,
2020-01-06 15:40 +08:00:   title: '最后新增一篇',
2020-01-06 15:40 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 15:40 +08:00:     '#### 技术选型\n' +
2020-01-06 15:40 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 15:40 +08:00:     '#### 开发环境\n' +
2020-01-06 15:40 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 15:40 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 15:40 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 15:40 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 15:40 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 15:40 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 15:40 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 15:40 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 15:40 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 15:40 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 15:40 +08:00:     '#### 整体架构\n' +
2020-01-06 15:40 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 15:40 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 15:40 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 15:40 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 15:40 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 15:40 +08:00:     '首先看下代码\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:40 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 15:40 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:40 +08:00:     '    title: "loading..."\n' +
2020-01-06 15:40 +08:00:     '  });\n' +
2020-01-06 15:40 +08:00:     '  try {\n' +
2020-01-06 15:40 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:40 +08:00:     '      url: HOST + url,\n' +
2020-01-06 15:40 +08:00:     '      method,\n' +
2020-01-06 15:40 +08:00:     '      data\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:40 +08:00:     '    return res;\n' +
2020-01-06 15:40 +08:00:     '  } catch (e) {\n' +
2020-01-06 15:40 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '    Taro.showToast({\n' +
2020-01-06 15:40 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 15:40 +08:00:     '      icon: "none"\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '  }\n' +
2020-01-06 15:40 +08:00:     '}\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '简单介绍一下～\n' +
2020-01-06 15:40 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 15:40 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 15:40 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 15:40 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 15:40 +08:00:     'show the code !\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:40 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 15:40 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 15:40 +08:00:     '  return {\n' +
2020-01-06 15:40 +08:00:     '    type: TYPE,\n' +
2020-01-06 15:40 +08:00:     '    payload: data\n' +
2020-01-06 15:40 +08:00:     '  };\n' +
2020-01-06 15:40 +08:00:     '};\n' +
2020-01-06 15:40 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 15:40 +08:00:     '  return {\n' +
2020-01-06 15:40 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 15:40 +08:00:     '    payload: data\n' +
2020-01-06 15:40 +08:00:     '  };\n' +
2020-01-06 15:40 +08:00:     '};\n' +
2020-01-06 15:40 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 15:40 +08:00:     '  return async dispatch => {\n' +
2020-01-06 15:40 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 15:40 +08:00:     '      title: "loading..."\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:40 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 15:40 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 15:40 +08:00:     '      data: option.data || ""\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:40 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 15:40 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 15:40 +08:00:     '    } else {\n' +
2020-01-06 15:40 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 15:40 +08:00:     '    }\n' +
2020-01-06 15:40 +08:00:     '    return res;\n' +
2020-01-06 15:40 +08:00:     '  };\n' +
2020-01-06 15:40 +08:00:     '}\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 15:40 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 15:40 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 15:40 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 15:40 +08:00:     '    return {\n' +
2020-01-06 15:40 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 15:40 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 15:40 +08:00:     '    };\n' +
2020-01-06 15:40 +08:00:     '  };\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:40 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:40 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 15:40 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 15:40 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 15:40 +08:00:     '    const data = {\n' +
2020-01-06 15:40 +08:00:     '      userOne,\n' +
2020-01-06 15:40 +08:00:     '      userTwo\n' +
2020-01-06 15:40 +08:00:     '    };\n' +
2020-01-06 15:40 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 15:40 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 15:40 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 15:40 +08:00:     '      }\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '  }\n' +
2020-01-06 15:40 +08:00:     '}\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 15:40 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 15:40 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 15:40 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 15:40 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:40 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:40 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 15:40 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 15:40 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 15:40 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 15:40 +08:00:     '    if (res.code) {\n' +
2020-01-06 15:40 +08:00: s.code;\n' +
2020-01-06 15:40 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 15:40 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 15:40 +08:00:     '          const data = {\n' +
2020-01-06 15:40 +08:00:     '            code: userCode,\n' +
2020-01-06 15:40 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 15:40 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 15:40 +08:00:     '          };\n' +
2020-01-06 15:40 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 15:40 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 15:40 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 15:40 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 15:40 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 15:40 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 15:40 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 15:40 +08:00:     '              });\n' +
2020-01-06 15:40 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 15:40 +08:00:     '                ver: "2.1"\n' +
2020-01-06 15:40 +08:00:     '              });\n' +
2020-01-06 15:40 +08:00:     '              if (shareId) {\n' +
2020-01-06 15:40 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 15:40 +08:00:     '              }\n' +
2020-01-06 15:40 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 15:40 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 15:40 +08:00:     '              });\n' +
2020-01-06 15:40 +08:00:     '            } else {\n' +
2020-01-06 15:40 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '              Taro.showToast({\n' +
2020-01-06 15:40 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 15:40 +08:00:     '                icon: "none"\n' +
2020-01-06 15:40 +08:00:     '              });\n' +
2020-01-06 15:40 +08:00:     '            }\n' +
2020-01-06 15:40 +08:00:     '          });\n' +
2020-01-06 15:40 +08:00:     '        })\n' +
2020-01-06 15:40 +08:00:     '        .catch(e => {\n' +
2020-01-06 15:40 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 15:40 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:40 +08:00:     '          });\n' +
2020-01-06 15:40 +08:00:     '        });\n' +
2020-01-06 15:40 +08:00:     '    } else {\n' +
2020-01-06 15:40 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '      Taro.showToast({\n' +
2020-01-06 15:40 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 15:40 +08:00:     '        icon: "none"\n' +
2020-01-06 15:40 +08:00:     '      });\n' +
2020-01-06 15:40 +08:00:     '    }\n' +
2020-01-06 15:40 +08:00:     '  });\n' +
2020-01-06 15:40 +08:00:     '};\n' +
2020-01-06 15:40 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 15:40 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:40 +08:00:     '    title: "loading...",\n' +
2020-01-06 15:40 +08:00:     '    icon: "loading"\n' +
2020-01-06 15:40 +08:00:     '  });\n' +
2020-01-06 15:40 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 15:40 +08:00:     '  if (!version) {\n' +
2020-01-06 15:40 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '    console.log("version", version);\n' +
2020-01-06 15:40 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:40 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 15:40 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 15:40 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:40 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '  } else {\n' +
2020-01-06 15:40 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 15:40 +08:00:     '      success: function() {\n' +
2020-01-06 15:40 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 15:40 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 15:40 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 15:40 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 15:40 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:40 +08:00:     '          });\n' +
2020-01-06 15:40 +08:00:     '        } else {\n' +
2020-01-06 15:40 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:40 +08:00:     '          if (shareId) {\n' +
2020-01-06 15:40 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 15:40 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 15:40 +08:00:     '          }\n' +
2020-01-06 15:40 +08:00:     '        }\n' +
2020-01-06 15:40 +08:00:     '      },\n' +
2020-01-06 15:40 +08:00:     '      fail: function() {\n' +
2020-01-06 15:40 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 15:40 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 15:40 +08:00:     '      }\n' +
2020-01-06 15:40 +08:00:     '    });\n' +
2020-01-06 15:40 +08:00:     '  }\n' +
2020-01-06 15:40 +08:00:     '}\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 15:40 +08:00:     '\n' +
2020-01-06 15:40 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '@connect(\n' +
2020-01-06 15:40 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 15:40 +08:00:     '  dispatch => ({\n' +
2020-01-06 15:40 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 15:40 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 15:40 +08:00:     '    },\n' +
2020-01-06 15:40 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 15:40 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 15:40 +08:00:     '    }\n' +
2020-01-06 15:40 +08:00:     '  })\n' +
2020-01-06 15:40 +08:00:     ')\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 15:40 +08:00:     '```\n' +
2020-01-06 15:40 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 15:40 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 15:40 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 15:40 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 15:40 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 15:40 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 15:40 +08:00:     '          this.setState({\n' +
2020-01-06 15:40 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 15:40 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 15:40 +08:00:     '          });\n' +
2020-01-06 15:40 +08:00:     '        }\n' +
2020-01-06 15:40 +08:00:     '      });\n' +
2020-01-06 15:40 +08:00:     '    }\n' +
2020-01-06 15:40 +08:00:     ' }\n' +
2020-01-06 15:40 +08:00:     '```',
2020-01-06 15:40 +08:00:   updatedAt: '2020-01-06 15:01',
2020-01-06 15:40 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 15:40 +08:00: }
2020-01-06 15:40 +08:00:   --> GET /api/v1/article/138 200 82ms 10.47kb
2020-01-06 15:44 +08:00:   <-- GET /api/v1/article/138
2020-01-06 15:44 +08:00: data {
2020-01-06 15:44 +08:00:   id: 138,
2020-01-06 15:44 +08:00:   title: '最后新增一篇',
2020-01-06 15:44 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 15:44 +08:00:     '#### 技术选型\n' +
2020-01-06 15:44 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 15:44 +08:00:     '#### 开发环境\n' +
2020-01-06 15:44 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 15:44 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 15:44 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 15:44 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 15:44 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 15:44 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 15:44 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 15:44 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 15:44 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 15:44 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 15:44 +08:00:     '#### 整体架构\n' +
2020-01-06 15:44 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 15:44 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 15:44 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 15:44 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 15:44 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 15:44 +08:00:     '首先看下代码\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:44 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 15:44 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:44 +08:00:     '    title: "loading..."\n' +
2020-01-06 15:44 +08:00:     '  });\n' +
2020-01-06 15:44 +08:00:     '  try {\n' +
2020-01-06 15:44 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:44 +08:00:     '      url: HOST + url,\n' +
2020-01-06 15:44 +08:00:     '      method,\n' +
2020-01-06 15:44 +08:00:     '      data\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:44 +08:00:     '    return res;\n' +
2020-01-06 15:44 +08:00:     '  } catch (e) {\n' +
2020-01-06 15:44 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '    Taro.showToast({\n' +
2020-01-06 15:44 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 15:44 +08:00:     '      icon: "none"\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '  }\n' +
2020-01-06 15:44 +08:00:     '}\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '简单介绍一下～\n' +
2020-01-06 15:44 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 15:44 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 15:44 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 15:44 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 15:44 +08:00:     'show the code !\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:44 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 15:44 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 15:44 +08:00:     '  return {\n' +
2020-01-06 15:44 +08:00:     '    type: TYPE,\n' +
2020-01-06 15:44 +08:00:     '    payload: data\n' +
2020-01-06 15:44 +08:00:     '  };\n' +
2020-01-06 15:44 +08:00:     '};\n' +
2020-01-06 15:44 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 15:44 +08:00:     '  return {\n' +
2020-01-06 15:44 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 15:44 +08:00:     '    payload: data\n' +
2020-01-06 15:44 +08:00:     '  };\n' +
2020-01-06 15:44 +08:00:     '};\n' +
2020-01-06 15:44 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 15:44 +08:00:     '  return async dispatch => {\n' +
2020-01-06 15:44 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 15:44 +08:00:     '      title: "loading..."\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:44 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 15:44 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 15:44 +08:00:     '      data: option.data || ""\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:44 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 15:44 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 15:44 +08:00:     '    } else {\n' +
2020-01-06 15:44 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 15:44 +08:00:     '    }\n' +
2020-01-06 15:44 +08:00:     '    return res;\n' +
2020-01-06 15:44 +08:00:     '  };\n' +
2020-01-06 15:44 +08:00:     '}\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 15:44 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 15:44 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 15:44 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 15:44 +08:00:     '    return {\n' +
2020-01-06 15:44 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 15:44 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 15:44 +08:00:     '    };\n' +
2020-01-06 15:44 +08:00:     '  };\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:44 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:44 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 15:44 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 15:44 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 15:44 +08:00:     '    const data = {\n' +
2020-01-06 15:44 +08:00:     '      userOne,\n' +
2020-01-06 15:44 +08:00:     '      userTwo\n' +
2020-01-06 15:44 +08:00:     '    };\n' +
2020-01-06 15:44 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 15:44 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 15:44 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 15:44 +08:00:     '      }\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '  }\n' +
2020-01-06 15:44 +08:00:     '}\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 15:44 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 15:44 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 15:44 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 15:44 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:44 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:44 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 15:44 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 15:44 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 15:44 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 15:44 +08:00:     '    if (res.code) {\n' +
2020-01-06 15:44 +08:00: s.code;\n' +
2020-01-06 15:44 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 15:44 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 15:44 +08:00:     '          const data = {\n' +
2020-01-06 15:44 +08:00:     '            code: userCode,\n' +
2020-01-06 15:44 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 15:44 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 15:44 +08:00:     '          };\n' +
2020-01-06 15:44 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 15:44 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 15:44 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 15:44 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 15:44 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 15:44 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 15:44 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 15:44 +08:00:     '              });\n' +
2020-01-06 15:44 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 15:44 +08:00:     '                ver: "2.1"\n' +
2020-01-06 15:44 +08:00:     '              });\n' +
2020-01-06 15:44 +08:00:     '              if (shareId) {\n' +
2020-01-06 15:44 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 15:44 +08:00:     '              }\n' +
2020-01-06 15:44 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 15:44 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 15:44 +08:00:     '              });\n' +
2020-01-06 15:44 +08:00:     '            } else {\n' +
2020-01-06 15:44 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '              Taro.showToast({\n' +
2020-01-06 15:44 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 15:44 +08:00:     '                icon: "none"\n' +
2020-01-06 15:44 +08:00:     '              });\n' +
2020-01-06 15:44 +08:00:     '            }\n' +
2020-01-06 15:44 +08:00:     '          });\n' +
2020-01-06 15:44 +08:00:     '        })\n' +
2020-01-06 15:44 +08:00:     '        .catch(e => {\n' +
2020-01-06 15:44 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 15:44 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:44 +08:00:     '          });\n' +
2020-01-06 15:44 +08:00:     '        });\n' +
2020-01-06 15:44 +08:00:     '    } else {\n' +
2020-01-06 15:44 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '      Taro.showToast({\n' +
2020-01-06 15:44 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 15:44 +08:00:     '        icon: "none"\n' +
2020-01-06 15:44 +08:00:     '      });\n' +
2020-01-06 15:44 +08:00:     '    }\n' +
2020-01-06 15:44 +08:00:     '  });\n' +
2020-01-06 15:44 +08:00:     '};\n' +
2020-01-06 15:44 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 15:44 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:44 +08:00:     '    title: "loading...",\n' +
2020-01-06 15:44 +08:00:     '    icon: "loading"\n' +
2020-01-06 15:44 +08:00:     '  });\n' +
2020-01-06 15:44 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 15:44 +08:00:     '  if (!version) {\n' +
2020-01-06 15:44 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '    console.log("version", version);\n' +
2020-01-06 15:44 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:44 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 15:44 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 15:44 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:44 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '  } else {\n' +
2020-01-06 15:44 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 15:44 +08:00:     '      success: function() {\n' +
2020-01-06 15:44 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 15:44 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 15:44 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 15:44 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 15:44 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:44 +08:00:     '          });\n' +
2020-01-06 15:44 +08:00:     '        } else {\n' +
2020-01-06 15:44 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:44 +08:00:     '          if (shareId) {\n' +
2020-01-06 15:44 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 15:44 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 15:44 +08:00:     '          }\n' +
2020-01-06 15:44 +08:00:     '        }\n' +
2020-01-06 15:44 +08:00:     '      },\n' +
2020-01-06 15:44 +08:00:     '      fail: function() {\n' +
2020-01-06 15:44 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 15:44 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 15:44 +08:00:     '      }\n' +
2020-01-06 15:44 +08:00:     '    });\n' +
2020-01-06 15:44 +08:00:     '  }\n' +
2020-01-06 15:44 +08:00:     '}\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 15:44 +08:00:     '\n' +
2020-01-06 15:44 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '@connect(\n' +
2020-01-06 15:44 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 15:44 +08:00:     '  dispatch => ({\n' +
2020-01-06 15:44 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 15:44 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 15:44 +08:00:     '    },\n' +
2020-01-06 15:44 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 15:44 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 15:44 +08:00:     '    }\n' +
2020-01-06 15:44 +08:00:     '  })\n' +
2020-01-06 15:44 +08:00:     ')\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 15:44 +08:00:     '```\n' +
2020-01-06 15:44 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 15:44 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 15:44 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 15:44 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 15:44 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 15:44 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 15:44 +08:00:     '          this.setState({\n' +
2020-01-06 15:44 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 15:44 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 15:44 +08:00:     '          });\n' +
2020-01-06 15:44 +08:00:     '        }\n' +
2020-01-06 15:44 +08:00:     '      });\n' +
2020-01-06 15:44 +08:00:     '    }\n' +
2020-01-06 15:44 +08:00:     ' }\n' +
2020-01-06 15:44 +08:00:     '```',
2020-01-06 15:44 +08:00:   updatedAt: '2020-01-06 15:01',
2020-01-06 15:44 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 15:44 +08:00: }
2020-01-06 15:44 +08:00:   --> GET /api/v1/article/138 200 12ms 10.47kb
2020-01-06 15:45 +08:00: server-koa server listening on 8080
2020-01-06 15:45 +08:00:   <-- GET /api/v1/article/138
2020-01-06 15:45 +08:00: data {
2020-01-06 15:45 +08:00:   id: 138,
2020-01-06 15:45 +08:00:   title: '最后新增一篇',
2020-01-06 15:45 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 15:45 +08:00:     '#### 技术选型\n' +
2020-01-06 15:45 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 15:45 +08:00:     '#### 开发环境\n' +
2020-01-06 15:45 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 15:45 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 15:45 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 15:45 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 15:45 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 15:45 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 15:45 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 15:45 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 15:45 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 15:45 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 15:45 +08:00:     '#### 整体架构\n' +
2020-01-06 15:45 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 15:45 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 15:45 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 15:45 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 15:45 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 15:45 +08:00:     '首先看下代码\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 15:45 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:45 +08:00:     '    title: "loading..."\n' +
2020-01-06 15:45 +08:00:     '  });\n' +
2020-01-06 15:45 +08:00:     '  try {\n' +
2020-01-06 15:45 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:45 +08:00:     '      url: HOST + url,\n' +
2020-01-06 15:45 +08:00:     '      method,\n' +
2020-01-06 15:45 +08:00:     '      data\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:45 +08:00:     '    return res;\n' +
2020-01-06 15:45 +08:00:     '  } catch (e) {\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    Taro.showToast({\n' +
2020-01-06 15:45 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 15:45 +08:00:     '      icon: "none"\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  }\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '简单介绍一下～\n' +
2020-01-06 15:45 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 15:45 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 15:45 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 15:45 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 15:45 +08:00:     'show the code !\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 15:45 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 15:45 +08:00:     '  return {\n' +
2020-01-06 15:45 +08:00:     '    type: TYPE,\n' +
2020-01-06 15:45 +08:00:     '    payload: data\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '};\n' +
2020-01-06 15:45 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 15:45 +08:00:     '  return {\n' +
2020-01-06 15:45 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 15:45 +08:00:     '    payload: data\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '};\n' +
2020-01-06 15:45 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 15:45 +08:00:     '  return async dispatch => {\n' +
2020-01-06 15:45 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 15:45 +08:00:     '      title: "loading..."\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:45 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 15:45 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 15:45 +08:00:     '      data: option.data || ""\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:45 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 15:45 +08:00:     '    } else {\n' +
2020-01-06 15:45 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     '    return res;\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 15:45 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 15:45 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 15:45 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 15:45 +08:00:     '    return {\n' +
2020-01-06 15:45 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 15:45 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 15:45 +08:00:     '    };\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:45 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 15:45 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 15:45 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 15:45 +08:00:     '    const data = {\n' +
2020-01-06 15:45 +08:00:     '      userOne,\n' +
2020-01-06 15:45 +08:00:     '      userTwo\n' +
2020-01-06 15:45 +08:00:     '    };\n' +
2020-01-06 15:45 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 15:45 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 15:45 +08:00:     '      }\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  }\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 15:45 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 15:45 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 15:45 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 15:45 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:45 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 15:45 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 15:45 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 15:45 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 15:45 +08:00:     '    if (res.code) {\n' +
2020-01-06 15:45 +08:00: s.code;\n' +
2020-01-06 15:45 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 15:45 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 15:45 +08:00:     '          const data = {\n' +
2020-01-06 15:45 +08:00:     '            code: userCode,\n' +
2020-01-06 15:45 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 15:45 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 15:45 +08:00:     '          };\n' +
2020-01-06 15:45 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 15:45 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 15:45 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 15:45 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 15:45 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 15:45 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 15:45 +08:00:     '                ver: "2.1"\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '              if (shareId) {\n' +
2020-01-06 15:45 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 15:45 +08:00:     '              }\n' +
2020-01-06 15:45 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 15:45 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '            } else {\n' +
2020-01-06 15:45 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '              Taro.showToast({\n' +
2020-01-06 15:45 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 15:45 +08:00:     '                icon: "none"\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '            }\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        })\n' +
2020-01-06 15:45 +08:00:     '        .catch(e => {\n' +
2020-01-06 15:45 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 15:45 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        });\n' +
2020-01-06 15:45 +08:00:     '    } else {\n' +
2020-01-06 15:45 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '      Taro.showToast({\n' +
2020-01-06 15:45 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 15:45 +08:00:     '        icon: "none"\n' +
2020-01-06 15:45 +08:00:     '      });\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     '  });\n' +
2020-01-06 15:45 +08:00:     '};\n' +
2020-01-06 15:45 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 15:45 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:45 +08:00:     '    title: "loading...",\n' +
2020-01-06 15:45 +08:00:     '    icon: "loading"\n' +
2020-01-06 15:45 +08:00:     '  });\n' +
2020-01-06 15:45 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 15:45 +08:00:     '  if (!version) {\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    console.log("version", version);\n' +
2020-01-06 15:45 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:45 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 15:45 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:45 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  } else {\n' +
2020-01-06 15:45 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 15:45 +08:00:     '      success: function() {\n' +
2020-01-06 15:45 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 15:45 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 15:45 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 15:45 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 15:45 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        } else {\n' +
2020-01-06 15:45 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '          if (shareId) {\n' +
2020-01-06 15:45 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 15:45 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 15:45 +08:00:     '          }\n' +
2020-01-06 15:45 +08:00:     '        }\n' +
2020-01-06 15:45 +08:00:     '      },\n' +
2020-01-06 15:45 +08:00:     '      fail: function() {\n' +
2020-01-06 15:45 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 15:45 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 15:45 +08:00:     '      }\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  }\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '@connect(\n' +
2020-01-06 15:45 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 15:45 +08:00:     '  dispatch => ({\n' +
2020-01-06 15:45 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 15:45 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 15:45 +08:00:     '    },\n' +
2020-01-06 15:45 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 15:45 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     '  })\n' +
2020-01-06 15:45 +08:00:     ')\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 15:45 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 15:45 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 15:45 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 15:45 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 15:45 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '          this.setState({\n' +
2020-01-06 15:45 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 15:45 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        }\n' +
2020-01-06 15:45 +08:00:     '      });\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     ' }\n' +
2020-01-06 15:45 +08:00:     '```',
2020-01-06 15:45 +08:00:   updatedAt: '2020-01-06 15:01',
2020-01-06 15:45 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 15:45 +08:00: }
2020-01-06 15:45 +08:00:   --> GET /api/v1/article/138 200 31ms 10.47kb
2020-01-06 15:45 +08:00: server-koa server listening on 8080
2020-01-06 15:45 +08:00:   <-- GET /api/v1/article/138
2020-01-06 15:45 +08:00: data {
2020-01-06 15:45 +08:00:   id: 138,
2020-01-06 15:45 +08:00:   title: '最后新增一篇',
2020-01-06 15:45 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 15:45 +08:00:     '#### 技术选型\n' +
2020-01-06 15:45 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 15:45 +08:00:     '#### 开发环境\n' +
2020-01-06 15:45 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 15:45 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 15:45 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 15:45 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 15:45 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 15:45 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 15:45 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 15:45 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 15:45 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 15:45 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 15:45 +08:00:     '#### 整体架构\n' +
2020-01-06 15:45 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 15:45 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 15:45 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 15:45 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 15:45 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 15:45 +08:00:     '首先看下代码\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 15:45 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:45 +08:00:     '    title: "loading..."\n' +
2020-01-06 15:45 +08:00:     '  });\n' +
2020-01-06 15:45 +08:00:     '  try {\n' +
2020-01-06 15:45 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:45 +08:00:     '      url: HOST + url,\n' +
2020-01-06 15:45 +08:00:     '      method,\n' +
2020-01-06 15:45 +08:00:     '      data\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:45 +08:00:     '    return res;\n' +
2020-01-06 15:45 +08:00:     '  } catch (e) {\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    Taro.showToast({\n' +
2020-01-06 15:45 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 15:45 +08:00:     '      icon: "none"\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  }\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '简单介绍一下～\n' +
2020-01-06 15:45 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 15:45 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 15:45 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 15:45 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 15:45 +08:00:     'show the code !\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 15:45 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 15:45 +08:00:     '  return {\n' +
2020-01-06 15:45 +08:00:     '    type: TYPE,\n' +
2020-01-06 15:45 +08:00:     '    payload: data\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '};\n' +
2020-01-06 15:45 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 15:45 +08:00:     '  return {\n' +
2020-01-06 15:45 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 15:45 +08:00:     '    payload: data\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '};\n' +
2020-01-06 15:45 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 15:45 +08:00:     '  return async dispatch => {\n' +
2020-01-06 15:45 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 15:45 +08:00:     '      title: "loading..."\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:45 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 15:45 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 15:45 +08:00:     '      data: option.data || ""\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:45 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 15:45 +08:00:     '    } else {\n' +
2020-01-06 15:45 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     '    return res;\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 15:45 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 15:45 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 15:45 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 15:45 +08:00:     '    return {\n' +
2020-01-06 15:45 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 15:45 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 15:45 +08:00:     '    };\n' +
2020-01-06 15:45 +08:00:     '  };\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:45 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 15:45 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 15:45 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 15:45 +08:00:     '    const data = {\n' +
2020-01-06 15:45 +08:00:     '      userOne,\n' +
2020-01-06 15:45 +08:00:     '      userTwo\n' +
2020-01-06 15:45 +08:00:     '    };\n' +
2020-01-06 15:45 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 15:45 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 15:45 +08:00:     '      }\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  }\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 15:45 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 15:45 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 15:45 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 15:45 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:45 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:45 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 15:45 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 15:45 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 15:45 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 15:45 +08:00:     '    if (res.code) {\n' +
2020-01-06 15:45 +08:00: s.code;\n' +
2020-01-06 15:45 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 15:45 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 15:45 +08:00:     '          const data = {\n' +
2020-01-06 15:45 +08:00:     '            code: userCode,\n' +
2020-01-06 15:45 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 15:45 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 15:45 +08:00:     '          };\n' +
2020-01-06 15:45 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 15:45 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 15:45 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 15:45 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 15:45 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 15:45 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 15:45 +08:00:     '                ver: "2.1"\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '              if (shareId) {\n' +
2020-01-06 15:45 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 15:45 +08:00:     '              }\n' +
2020-01-06 15:45 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 15:45 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '            } else {\n' +
2020-01-06 15:45 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '              Taro.showToast({\n' +
2020-01-06 15:45 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 15:45 +08:00:     '                icon: "none"\n' +
2020-01-06 15:45 +08:00:     '              });\n' +
2020-01-06 15:45 +08:00:     '            }\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        })\n' +
2020-01-06 15:45 +08:00:     '        .catch(e => {\n' +
2020-01-06 15:45 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 15:45 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        });\n' +
2020-01-06 15:45 +08:00:     '    } else {\n' +
2020-01-06 15:45 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '      Taro.showToast({\n' +
2020-01-06 15:45 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 15:45 +08:00:     '        icon: "none"\n' +
2020-01-06 15:45 +08:00:     '      });\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     '  });\n' +
2020-01-06 15:45 +08:00:     '};\n' +
2020-01-06 15:45 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 15:45 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:45 +08:00:     '    title: "loading...",\n' +
2020-01-06 15:45 +08:00:     '    icon: "loading"\n' +
2020-01-06 15:45 +08:00:     '  });\n' +
2020-01-06 15:45 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 15:45 +08:00:     '  if (!version) {\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    console.log("version", version);\n' +
2020-01-06 15:45 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:45 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 15:45 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 15:45 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:45 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  } else {\n' +
2020-01-06 15:45 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 15:45 +08:00:     '      success: function() {\n' +
2020-01-06 15:45 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 15:45 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 15:45 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 15:45 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 15:45 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        } else {\n' +
2020-01-06 15:45 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:45 +08:00:     '          if (shareId) {\n' +
2020-01-06 15:45 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 15:45 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 15:45 +08:00:     '          }\n' +
2020-01-06 15:45 +08:00:     '        }\n' +
2020-01-06 15:45 +08:00:     '      },\n' +
2020-01-06 15:45 +08:00:     '      fail: function() {\n' +
2020-01-06 15:45 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 15:45 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 15:45 +08:00:     '      }\n' +
2020-01-06 15:45 +08:00:     '    });\n' +
2020-01-06 15:45 +08:00:     '  }\n' +
2020-01-06 15:45 +08:00:     '}\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 15:45 +08:00:     '\n' +
2020-01-06 15:45 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '@connect(\n' +
2020-01-06 15:45 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 15:45 +08:00:     '  dispatch => ({\n' +
2020-01-06 15:45 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 15:45 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 15:45 +08:00:     '    },\n' +
2020-01-06 15:45 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 15:45 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     '  })\n' +
2020-01-06 15:45 +08:00:     ')\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 15:45 +08:00:     '```\n' +
2020-01-06 15:45 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 15:45 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 15:45 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 15:45 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 15:45 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 15:45 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 15:45 +08:00:     '          this.setState({\n' +
2020-01-06 15:45 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 15:45 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 15:45 +08:00:     '          });\n' +
2020-01-06 15:45 +08:00:     '        }\n' +
2020-01-06 15:45 +08:00:     '      });\n' +
2020-01-06 15:45 +08:00:     '    }\n' +
2020-01-06 15:45 +08:00:     ' }\n' +
2020-01-06 15:45 +08:00:     '```',
2020-01-06 15:45 +08:00:   updatedAt: '2020-01-06 15:01',
2020-01-06 15:45 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 15:45 +08:00: }
2020-01-06 15:45 +08:00:   --> GET /api/v1/article/138 200 47ms 10.47kb
2020-01-06 15:46 +08:00: server-koa server listening on 8080
2020-01-06 15:46 +08:00:   <-- GET /api/v1/article/138
2020-01-06 15:46 +08:00: data {
2020-01-06 15:46 +08:00:   id: 138,
2020-01-06 15:46 +08:00:   title: '最后新增一篇',
2020-01-06 15:46 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 15:46 +08:00:     '#### 技术选型\n' +
2020-01-06 15:46 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 15:46 +08:00:     '#### 开发环境\n' +
2020-01-06 15:46 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 15:46 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 15:46 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 15:46 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 15:46 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 15:46 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 15:46 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 15:46 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 15:46 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 15:46 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 15:46 +08:00:     '#### 整体架构\n' +
2020-01-06 15:46 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 15:46 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 15:46 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 15:46 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 15:46 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 15:46 +08:00:     '首先看下代码\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 15:46 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '    title: "loading..."\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '  try {\n' +
2020-01-06 15:46 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:46 +08:00:     '      url: HOST + url,\n' +
2020-01-06 15:46 +08:00:     '      method,\n' +
2020-01-06 15:46 +08:00:     '      data\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:46 +08:00:     '    return res;\n' +
2020-01-06 15:46 +08:00:     '  } catch (e) {\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 15:46 +08:00:     '      icon: "none"\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '简单介绍一下～\n' +
2020-01-06 15:46 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 15:46 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 15:46 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 15:46 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 15:46 +08:00:     'show the code !\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 15:46 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 15:46 +08:00:     '  return {\n' +
2020-01-06 15:46 +08:00:     '    type: TYPE,\n' +
2020-01-06 15:46 +08:00:     '    payload: data\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 15:46 +08:00:     '  return {\n' +
2020-01-06 15:46 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 15:46 +08:00:     '    payload: data\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 15:46 +08:00:     '  return async dispatch => {\n' +
2020-01-06 15:46 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '      title: "loading..."\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:46 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 15:46 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 15:46 +08:00:     '      data: option.data || ""\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:46 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 15:46 +08:00:     '    } else {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '    return res;\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 15:46 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 15:46 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 15:46 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 15:46 +08:00:     '    return {\n' +
2020-01-06 15:46 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 15:46 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 15:46 +08:00:     '    };\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:46 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 15:46 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 15:46 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 15:46 +08:00:     '    const data = {\n' +
2020-01-06 15:46 +08:00:     '      userOne,\n' +
2020-01-06 15:46 +08:00:     '      userTwo\n' +
2020-01-06 15:46 +08:00:     '    };\n' +
2020-01-06 15:46 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 15:46 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 15:46 +08:00:     '      }\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 15:46 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 15:46 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 15:46 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 15:46 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:46 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 15:46 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 15:46 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 15:46 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 15:46 +08:00:     '    if (res.code) {\n' +
2020-01-06 15:46 +08:00: s.code;\n' +
2020-01-06 15:46 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 15:46 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 15:46 +08:00:     '          const data = {\n' +
2020-01-06 15:46 +08:00:     '            code: userCode,\n' +
2020-01-06 15:46 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 15:46 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 15:46 +08:00:     '          };\n' +
2020-01-06 15:46 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 15:46 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 15:46 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 15:46 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 15:46 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 15:46 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 15:46 +08:00:     '                ver: "2.1"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '              if (shareId) {\n' +
2020-01-06 15:46 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 15:46 +08:00:     '              }\n' +
2020-01-06 15:46 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 15:46 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '            } else {\n' +
2020-01-06 15:46 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '              Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 15:46 +08:00:     '                icon: "none"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '            }\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        })\n' +
2020-01-06 15:46 +08:00:     '        .catch(e => {\n' +
2020-01-06 15:46 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        });\n' +
2020-01-06 15:46 +08:00:     '    } else {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 15:46 +08:00:     '        icon: "none"\n' +
2020-01-06 15:46 +08:00:     '      });\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 15:46 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '    title: "loading...",\n' +
2020-01-06 15:46 +08:00:     '    icon: "loading"\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 15:46 +08:00:     '  if (!version) {\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    console.log("version", version);\n' +
2020-01-06 15:46 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 15:46 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  } else {\n' +
2020-01-06 15:46 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 15:46 +08:00:     '      success: function() {\n' +
2020-01-06 15:46 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 15:46 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 15:46 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 15:46 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 15:46 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        } else {\n' +
2020-01-06 15:46 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '          if (shareId) {\n' +
2020-01-06 15:46 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 15:46 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 15:46 +08:00:     '          }\n' +
2020-01-06 15:46 +08:00:     '        }\n' +
2020-01-06 15:46 +08:00:     '      },\n' +
2020-01-06 15:46 +08:00:     '      fail: function() {\n' +
2020-01-06 15:46 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 15:46 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 15:46 +08:00:     '      }\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '@connect(\n' +
2020-01-06 15:46 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 15:46 +08:00:     '  dispatch => ({\n' +
2020-01-06 15:46 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 15:46 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 15:46 +08:00:     '    },\n' +
2020-01-06 15:46 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 15:46 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '  })\n' +
2020-01-06 15:46 +08:00:     ')\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 15:46 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 15:46 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 15:46 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 15:46 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 15:46 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '          this.setState({\n' +
2020-01-06 15:46 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 15:46 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        }\n' +
2020-01-06 15:46 +08:00:     '      });\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     ' }\n' +
2020-01-06 15:46 +08:00:     '```',
2020-01-06 15:46 +08:00:   updatedAt: '2020-01-06 15:01',
2020-01-06 15:46 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 15:46 +08:00: }
2020-01-06 15:46 +08:00:   --> GET /api/v1/article/138 200 48ms 10.47kb
2020-01-06 15:46 +08:00:   <-- GET /api/v1/article/138
2020-01-06 15:46 +08:00: data {
2020-01-06 15:46 +08:00:   id: 138,
2020-01-06 15:46 +08:00:   title: '最后新增一篇',
2020-01-06 15:46 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 15:46 +08:00:     '#### 技术选型\n' +
2020-01-06 15:46 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 15:46 +08:00:     '#### 开发环境\n' +
2020-01-06 15:46 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 15:46 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 15:46 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 15:46 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 15:46 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 15:46 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 15:46 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 15:46 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 15:46 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 15:46 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 15:46 +08:00:     '#### 整体架构\n' +
2020-01-06 15:46 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 15:46 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 15:46 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 15:46 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 15:46 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 15:46 +08:00:     '首先看下代码\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 15:46 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '    title: "loading..."\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '  try {\n' +
2020-01-06 15:46 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:46 +08:00:     '      url: HOST + url,\n' +
2020-01-06 15:46 +08:00:     '      method,\n' +
2020-01-06 15:46 +08:00:     '      data\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:46 +08:00:     '    return res;\n' +
2020-01-06 15:46 +08:00:     '  } catch (e) {\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 15:46 +08:00:     '      icon: "none"\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '简单介绍一下～\n' +
2020-01-06 15:46 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 15:46 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 15:46 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 15:46 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 15:46 +08:00:     'show the code !\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 15:46 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 15:46 +08:00:     '  return {\n' +
2020-01-06 15:46 +08:00:     '    type: TYPE,\n' +
2020-01-06 15:46 +08:00:     '    payload: data\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 15:46 +08:00:     '  return {\n' +
2020-01-06 15:46 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 15:46 +08:00:     '    payload: data\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 15:46 +08:00:     '  return async dispatch => {\n' +
2020-01-06 15:46 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '      title: "loading..."\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:46 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 15:46 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 15:46 +08:00:     '      data: option.data || ""\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:46 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 15:46 +08:00:     '    } else {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '    return res;\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 15:46 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 15:46 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 15:46 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 15:46 +08:00:     '    return {\n' +
2020-01-06 15:46 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 15:46 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 15:46 +08:00:     '    };\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:46 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 15:46 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 15:46 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 15:46 +08:00:     '    const data = {\n' +
2020-01-06 15:46 +08:00:     '      userOne,\n' +
2020-01-06 15:46 +08:00:     '      userTwo\n' +
2020-01-06 15:46 +08:00:     '    };\n' +
2020-01-06 15:46 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 15:46 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 15:46 +08:00:     '      }\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 15:46 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 15:46 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 15:46 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 15:46 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:46 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 15:46 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 15:46 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 15:46 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 15:46 +08:00:     '    if (res.code) {\n' +
2020-01-06 15:46 +08:00: s.code;\n' +
2020-01-06 15:46 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 15:46 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 15:46 +08:00:     '          const data = {\n' +
2020-01-06 15:46 +08:00:     '            code: userCode,\n' +
2020-01-06 15:46 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 15:46 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 15:46 +08:00:     '          };\n' +
2020-01-06 15:46 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 15:46 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 15:46 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 15:46 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 15:46 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 15:46 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 15:46 +08:00:     '                ver: "2.1"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '              if (shareId) {\n' +
2020-01-06 15:46 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 15:46 +08:00:     '              }\n' +
2020-01-06 15:46 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 15:46 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '            } else {\n' +
2020-01-06 15:46 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '              Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 15:46 +08:00:     '                icon: "none"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '            }\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        })\n' +
2020-01-06 15:46 +08:00:     '        .catch(e => {\n' +
2020-01-06 15:46 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        });\n' +
2020-01-06 15:46 +08:00:     '    } else {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 15:46 +08:00:     '        icon: "none"\n' +
2020-01-06 15:46 +08:00:     '      });\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 15:46 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '    title: "loading...",\n' +
2020-01-06 15:46 +08:00:     '    icon: "loading"\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 15:46 +08:00:     '  if (!version) {\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    console.log("version", version);\n' +
2020-01-06 15:46 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 15:46 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  } else {\n' +
2020-01-06 15:46 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 15:46 +08:00:     '      success: function() {\n' +
2020-01-06 15:46 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 15:46 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 15:46 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 15:46 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 15:46 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        } else {\n' +
2020-01-06 15:46 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '          if (shareId) {\n' +
2020-01-06 15:46 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 15:46 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 15:46 +08:00:     '          }\n' +
2020-01-06 15:46 +08:00:     '        }\n' +
2020-01-06 15:46 +08:00:     '      },\n' +
2020-01-06 15:46 +08:00:     '      fail: function() {\n' +
2020-01-06 15:46 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 15:46 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 15:46 +08:00:     '      }\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '@connect(\n' +
2020-01-06 15:46 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 15:46 +08:00:     '  dispatch => ({\n' +
2020-01-06 15:46 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 15:46 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 15:46 +08:00:     '    },\n' +
2020-01-06 15:46 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 15:46 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '  })\n' +
2020-01-06 15:46 +08:00:     ')\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 15:46 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 15:46 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 15:46 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 15:46 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 15:46 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '          this.setState({\n' +
2020-01-06 15:46 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 15:46 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        }\n' +
2020-01-06 15:46 +08:00:     '      });\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     ' }\n' +
2020-01-06 15:46 +08:00:     '```',
2020-01-06 15:46 +08:00:   updatedAt: '2020-01-06 15:01',
2020-01-06 15:46 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 15:46 +08:00: }
2020-01-06 15:46 +08:00:   --> GET /api/v1/article/138 200 11ms 10.47kb
2020-01-06 15:46 +08:00:   <-- GET /api/v1/article/138
2020-01-06 15:46 +08:00: data {
2020-01-06 15:46 +08:00:   id: 138,
2020-01-06 15:46 +08:00:   title: '最后新增一篇',
2020-01-06 15:46 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 15:46 +08:00:     '#### 技术选型\n' +
2020-01-06 15:46 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 15:46 +08:00:     '#### 开发环境\n' +
2020-01-06 15:46 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 15:46 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 15:46 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 15:46 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 15:46 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 15:46 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 15:46 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 15:46 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 15:46 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 15:46 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 15:46 +08:00:     '#### 整体架构\n' +
2020-01-06 15:46 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 15:46 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 15:46 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 15:46 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 15:46 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 15:46 +08:00:     '首先看下代码\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 15:46 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '    title: "loading..."\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '  try {\n' +
2020-01-06 15:46 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:46 +08:00:     '      url: HOST + url,\n' +
2020-01-06 15:46 +08:00:     '      method,\n' +
2020-01-06 15:46 +08:00:     '      data\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:46 +08:00:     '    return res;\n' +
2020-01-06 15:46 +08:00:     '  } catch (e) {\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 15:46 +08:00:     '      icon: "none"\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '简单介绍一下～\n' +
2020-01-06 15:46 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 15:46 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 15:46 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 15:46 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 15:46 +08:00:     'show the code !\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 15:46 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 15:46 +08:00:     '  return {\n' +
2020-01-06 15:46 +08:00:     '    type: TYPE,\n' +
2020-01-06 15:46 +08:00:     '    payload: data\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 15:46 +08:00:     '  return {\n' +
2020-01-06 15:46 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 15:46 +08:00:     '    payload: data\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 15:46 +08:00:     '  return async dispatch => {\n' +
2020-01-06 15:46 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '      title: "loading..."\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 15:46 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 15:46 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 15:46 +08:00:     '      data: option.data || ""\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '    const res = response.data;\n' +
2020-01-06 15:46 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 15:46 +08:00:     '    } else {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '    return res;\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 15:46 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 15:46 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 15:46 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 15:46 +08:00:     '    return {\n' +
2020-01-06 15:46 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 15:46 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 15:46 +08:00:     '    };\n' +
2020-01-06 15:46 +08:00:     '  };\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:46 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 15:46 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 15:46 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 15:46 +08:00:     '    const data = {\n' +
2020-01-06 15:46 +08:00:     '      userOne,\n' +
2020-01-06 15:46 +08:00:     '      userTwo\n' +
2020-01-06 15:46 +08:00:     '    };\n' +
2020-01-06 15:46 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 15:46 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 15:46 +08:00:     '      }\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 15:46 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 15:46 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 15:46 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 15:46 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 15:46 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 15:46 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 15:46 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 15:46 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 15:46 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 15:46 +08:00:     '    if (res.code) {\n' +
2020-01-06 15:46 +08:00: s.code;\n' +
2020-01-06 15:46 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 15:46 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 15:46 +08:00:     '          const data = {\n' +
2020-01-06 15:46 +08:00:     '            code: userCode,\n' +
2020-01-06 15:46 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 15:46 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 15:46 +08:00:     '          };\n' +
2020-01-06 15:46 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 15:46 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 15:46 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 15:46 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 15:46 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 15:46 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 15:46 +08:00:     '                ver: "2.1"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '              if (shareId) {\n' +
2020-01-06 15:46 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 15:46 +08:00:     '              }\n' +
2020-01-06 15:46 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 15:46 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '            } else {\n' +
2020-01-06 15:46 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '              Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 15:46 +08:00:     '                icon: "none"\n' +
2020-01-06 15:46 +08:00:     '              });\n' +
2020-01-06 15:46 +08:00:     '            }\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        })\n' +
2020-01-06 15:46 +08:00:     '        .catch(e => {\n' +
2020-01-06 15:46 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        });\n' +
2020-01-06 15:46 +08:00:     '    } else {\n' +
2020-01-06 15:46 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '      Taro.showToast({\n' +
2020-01-06 15:46 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 15:46 +08:00:     '        icon: "none"\n' +
2020-01-06 15:46 +08:00:     '      });\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '};\n' +
2020-01-06 15:46 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 15:46 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 15:46 +08:00:     '    title: "loading...",\n' +
2020-01-06 15:46 +08:00:     '    icon: "loading"\n' +
2020-01-06 15:46 +08:00:     '  });\n' +
2020-01-06 15:46 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 15:46 +08:00:     '  if (!version) {\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    console.log("version", version);\n' +
2020-01-06 15:46 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 15:46 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 15:46 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 15:46 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  } else {\n' +
2020-01-06 15:46 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 15:46 +08:00:     '      success: function() {\n' +
2020-01-06 15:46 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 15:46 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 15:46 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 15:46 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 15:46 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        } else {\n' +
2020-01-06 15:46 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 15:46 +08:00:     '          if (shareId) {\n' +
2020-01-06 15:46 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 15:46 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 15:46 +08:00:     '          }\n' +
2020-01-06 15:46 +08:00:     '        }\n' +
2020-01-06 15:46 +08:00:     '      },\n' +
2020-01-06 15:46 +08:00:     '      fail: function() {\n' +
2020-01-06 15:46 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 15:46 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 15:46 +08:00:     '      }\n' +
2020-01-06 15:46 +08:00:     '    });\n' +
2020-01-06 15:46 +08:00:     '  }\n' +
2020-01-06 15:46 +08:00:     '}\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 15:46 +08:00:     '\n' +
2020-01-06 15:46 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '@connect(\n' +
2020-01-06 15:46 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 15:46 +08:00:     '  dispatch => ({\n' +
2020-01-06 15:46 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 15:46 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 15:46 +08:00:     '    },\n' +
2020-01-06 15:46 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 15:46 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     '  })\n' +
2020-01-06 15:46 +08:00:     ')\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 15:46 +08:00:     '```\n' +
2020-01-06 15:46 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 15:46 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 15:46 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 15:46 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 15:46 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 15:46 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 15:46 +08:00:     '          this.setState({\n' +
2020-01-06 15:46 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 15:46 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 15:46 +08:00:     '          });\n' +
2020-01-06 15:46 +08:00:     '        }\n' +
2020-01-06 15:46 +08:00:     '      });\n' +
2020-01-06 15:46 +08:00:     '    }\n' +
2020-01-06 15:46 +08:00:     ' }\n' +
2020-01-06 15:46 +08:00:     '```',
2020-01-06 15:46 +08:00:   updatedAt: '2020-01-06 15:01',
2020-01-06 15:46 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 15:46 +08:00: }
2020-01-06 15:46 +08:00:   --> GET /api/v1/article/138 200 7ms 10.47kb
2020-01-06 16:04 +08:00: server-koa server listening on 8080
2020-01-06 16:05 +08:00: server-koa server listening on 8080
2020-01-06 16:05 +08:00:   <-- GET /api/v1/article/138
2020-01-06 16:05 +08:00: data {
2020-01-06 16:05 +08:00:   id: 138,
2020-01-06 16:05 +08:00:   title: '最后新增一篇',
2020-01-06 16:05 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 16:05 +08:00:     '#### 技术选型\n' +
2020-01-06 16:05 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 16:05 +08:00:     '#### 开发环境\n' +
2020-01-06 16:05 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 16:05 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 16:05 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 16:05 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 16:05 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 16:05 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 16:05 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 16:05 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 16:05 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 16:05 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 16:05 +08:00:     '#### 整体架构\n' +
2020-01-06 16:05 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 16:05 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 16:05 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 16:05 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 16:05 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 16:05 +08:00:     '首先看下代码\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:05 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 16:05 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 16:05 +08:00:     '    title: "loading..."\n' +
2020-01-06 16:05 +08:00:     '  });\n' +
2020-01-06 16:05 +08:00:     '  try {\n' +
2020-01-06 16:05 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 16:05 +08:00:     '      url: HOST + url,\n' +
2020-01-06 16:05 +08:00:     '      method,\n' +
2020-01-06 16:05 +08:00:     '      data\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '    const res = response.data;\n' +
2020-01-06 16:05 +08:00:     '    return res;\n' +
2020-01-06 16:05 +08:00:     '  } catch (e) {\n' +
2020-01-06 16:05 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '    Taro.showToast({\n' +
2020-01-06 16:05 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 16:05 +08:00:     '      icon: "none"\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '  }\n' +
2020-01-06 16:05 +08:00:     '}\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '简单介绍一下～\n' +
2020-01-06 16:05 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 16:05 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 16:05 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 16:05 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 16:05 +08:00:     'show the code !\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:05 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 16:05 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 16:05 +08:00:     '  return {\n' +
2020-01-06 16:05 +08:00:     '    type: TYPE,\n' +
2020-01-06 16:05 +08:00:     '    payload: data\n' +
2020-01-06 16:05 +08:00:     '  };\n' +
2020-01-06 16:05 +08:00:     '};\n' +
2020-01-06 16:05 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 16:05 +08:00:     '  return {\n' +
2020-01-06 16:05 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 16:05 +08:00:     '    payload: data\n' +
2020-01-06 16:05 +08:00:     '  };\n' +
2020-01-06 16:05 +08:00:     '};\n' +
2020-01-06 16:05 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 16:05 +08:00:     '  return async dispatch => {\n' +
2020-01-06 16:05 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 16:05 +08:00:     '      title: "loading..."\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 16:05 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 16:05 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 16:05 +08:00:     '      data: option.data || ""\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '    const res = response.data;\n' +
2020-01-06 16:05 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 16:05 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 16:05 +08:00:     '    } else {\n' +
2020-01-06 16:05 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 16:05 +08:00:     '    }\n' +
2020-01-06 16:05 +08:00:     '    return res;\n' +
2020-01-06 16:05 +08:00:     '  };\n' +
2020-01-06 16:05 +08:00:     '}\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 16:05 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 16:05 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 16:05 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 16:05 +08:00:     '    return {\n' +
2020-01-06 16:05 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 16:05 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 16:05 +08:00:     '    };\n' +
2020-01-06 16:05 +08:00:     '  };\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:05 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 16:05 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 16:05 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 16:05 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 16:05 +08:00:     '    const data = {\n' +
2020-01-06 16:05 +08:00:     '      userOne,\n' +
2020-01-06 16:05 +08:00:     '      userTwo\n' +
2020-01-06 16:05 +08:00:     '    };\n' +
2020-01-06 16:05 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 16:05 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 16:05 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 16:05 +08:00:     '      }\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '  }\n' +
2020-01-06 16:05 +08:00:     '}\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 16:05 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 16:05 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 16:05 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 16:05 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:05 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 16:05 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 16:05 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 16:05 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 16:05 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 16:05 +08:00:     '    if (res.code) {\n' +
2020-01-06 16:05 +08:00: s.code;\n' +
2020-01-06 16:05 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 16:05 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 16:05 +08:00:     '          const data = {\n' +
2020-01-06 16:05 +08:00:     '            code: userCode,\n' +
2020-01-06 16:05 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 16:05 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 16:05 +08:00:     '          };\n' +
2020-01-06 16:05 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 16:05 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 16:05 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 16:05 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 16:05 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 16:05 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 16:05 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 16:05 +08:00:     '              });\n' +
2020-01-06 16:05 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 16:05 +08:00:     '                ver: "2.1"\n' +
2020-01-06 16:05 +08:00:     '              });\n' +
2020-01-06 16:05 +08:00:     '              if (shareId) {\n' +
2020-01-06 16:05 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 16:05 +08:00:     '              }\n' +
2020-01-06 16:05 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 16:05 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 16:05 +08:00:     '              });\n' +
2020-01-06 16:05 +08:00:     '            } else {\n' +
2020-01-06 16:05 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '              Taro.showToast({\n' +
2020-01-06 16:05 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 16:05 +08:00:     '                icon: "none"\n' +
2020-01-06 16:05 +08:00:     '              });\n' +
2020-01-06 16:05 +08:00:     '            }\n' +
2020-01-06 16:05 +08:00:     '          });\n' +
2020-01-06 16:05 +08:00:     '        })\n' +
2020-01-06 16:05 +08:00:     '        .catch(e => {\n' +
2020-01-06 16:05 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 16:05 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:05 +08:00:     '          });\n' +
2020-01-06 16:05 +08:00:     '        });\n' +
2020-01-06 16:05 +08:00:     '    } else {\n' +
2020-01-06 16:05 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '      Taro.showToast({\n' +
2020-01-06 16:05 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 16:05 +08:00:     '        icon: "none"\n' +
2020-01-06 16:05 +08:00:     '      });\n' +
2020-01-06 16:05 +08:00:     '    }\n' +
2020-01-06 16:05 +08:00:     '  });\n' +
2020-01-06 16:05 +08:00:     '};\n' +
2020-01-06 16:05 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 16:05 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 16:05 +08:00:     '    title: "loading...",\n' +
2020-01-06 16:05 +08:00:     '    icon: "loading"\n' +
2020-01-06 16:05 +08:00:     '  });\n' +
2020-01-06 16:05 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 16:05 +08:00:     '  if (!version) {\n' +
2020-01-06 16:05 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '    console.log("version", version);\n' +
2020-01-06 16:05 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 16:05 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 16:05 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 16:05 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 16:05 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '  } else {\n' +
2020-01-06 16:05 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 16:05 +08:00:     '      success: function() {\n' +
2020-01-06 16:05 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 16:05 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 16:05 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 16:05 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 16:05 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:05 +08:00:     '          });\n' +
2020-01-06 16:05 +08:00:     '        } else {\n' +
2020-01-06 16:05 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 16:05 +08:00:     '          if (shareId) {\n' +
2020-01-06 16:05 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 16:05 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 16:05 +08:00:     '          }\n' +
2020-01-06 16:05 +08:00:     '        }\n' +
2020-01-06 16:05 +08:00:     '      },\n' +
2020-01-06 16:05 +08:00:     '      fail: function() {\n' +
2020-01-06 16:05 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 16:05 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 16:05 +08:00:     '      }\n' +
2020-01-06 16:05 +08:00:     '    });\n' +
2020-01-06 16:05 +08:00:     '  }\n' +
2020-01-06 16:05 +08:00:     '}\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 16:05 +08:00:     '\n' +
2020-01-06 16:05 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '@connect(\n' +
2020-01-06 16:05 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 16:05 +08:00:     '  dispatch => ({\n' +
2020-01-06 16:05 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 16:05 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 16:05 +08:00:     '    },\n' +
2020-01-06 16:05 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 16:05 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 16:05 +08:00:     '    }\n' +
2020-01-06 16:05 +08:00:     '  })\n' +
2020-01-06 16:05 +08:00:     ')\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 16:05 +08:00:     '```\n' +
2020-01-06 16:05 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 16:05 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 16:05 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 16:05 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 16:05 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 16:05 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 16:05 +08:00:     '          this.setState({\n' +
2020-01-06 16:05 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 16:05 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 16:05 +08:00:     '          });\n' +
2020-01-06 16:05 +08:00:     '        }\n' +
2020-01-06 16:05 +08:00:     '      });\n' +
2020-01-06 16:05 +08:00:     '    }\n' +
2020-01-06 16:05 +08:00:     ' }\n' +
2020-01-06 16:05 +08:00:     '```',
2020-01-06 16:05 +08:00:   updatedAt: '2020-01-06 16:01',
2020-01-06 16:05 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 16:05 +08:00: }
2020-01-06 16:05 +08:00:   --> GET /api/v1/article/138 200 39ms 10.47kb
2020-01-06 16:13 +08:00: server-koa server listening on 8080
2020-01-06 16:58 +08:00:   <-- GET /api/v1/article/138
2020-01-06 16:58 +08:00: data {
2020-01-06 16:58 +08:00:   id: 138,
2020-01-06 16:58 +08:00:   title: '最后新增一篇',
2020-01-06 16:58 +08:00:   content: '### 项目基本介绍\n' +
2020-01-06 16:58 +08:00:     '#### 技术选型\n' +
2020-01-06 16:58 +08:00:     '采用微信小程序开发框架--- Taro，截止目前taro框架在github上的star 数已经突破18k，该框架采用react语法开发微信小程序，在一定程度上解决了小程序原生的开发方式的一些不足。\n' +
2020-01-06 16:58 +08:00:     '#### 开发环境\n' +
2020-01-06 16:58 +08:00:     '- 环境：node v11.0，taro官方脚手架模块化及打包\n' +
2020-01-06 16:58 +08:00:     '- 编辑器：vscode\n' +
2020-01-06 16:58 +08:00:     '- 调试与测试：微信开发者工具稳定版\n' +
2020-01-06 16:58 +08:00:     '#### 第三方框架与组件\n' +
2020-01-06 16:58 +08:00:     '1. 开发框架：Taro\n' +
2020-01-06 16:58 +08:00:     '2. ui框架：taro-ui\n' +
2020-01-06 16:58 +08:00:     '3. 数据流框架：tarojs/redux\n' +
2020-01-06 16:58 +08:00:     '4. 图表渲染框架：echarts-for-weixin\n' +
2020-01-06 16:58 +08:00:     '#### 项目目录如下所示\n' +
2020-01-06 16:58 +08:00:     '![42d4ca156ea10a37f7a1ea942a323e3e.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1395)\n' +
2020-01-06 16:58 +08:00:     '#### 整体架构\n' +
2020-01-06 16:58 +08:00:     '![baf615b0fcedb4280abbf41944eeb81a.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1394)\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '### 项目数据流状态的管理\n' +
2020-01-06 16:58 +08:00:     '- 数据状态管理是前端开发中较为困难的一部分，若前期数据状态管理十分混乱，会导致在后续产品迭代，需求变化的过程中，出现难以维护的情况。\n' +
2020-01-06 16:58 +08:00:     '- 由于此小程序使用的taro开发框架应用react语法，而redux作为一种可预测的状态容器，在react生态中十分的流行，加之taro对redux的支持非常好，taro官方也十分支持在taro框架中使用redux进行管理数据，此小程序采用tarojs/redux来进行管理数据状态。\n' +
2020-01-06 16:58 +08:00:     '![36b18bd005e51675a1e548746f9d1af8.png](evernotecid://060A896A-CDFC-4AF3-A6D0-3BB4B4DF2D86/appyinxiangcom/18130370/ENResource/p1393)\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '### 项目中对工具函数的封装\n' +
2020-01-06 16:58 +08:00:     '#### 对小程序request请求的封装\n' +
2020-01-06 16:58 +08:00:     '首先看下代码\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:58 +08:00:     'const HOST = "https://pgrk.wizzstudio.com";\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     'export default async function myApi(url, method = "GET", data = {}) {\n' +
2020-01-06 16:58 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 16:58 +08:00:     '    title: "loading..."\n' +
2020-01-06 16:58 +08:00:     '  });\n' +
2020-01-06 16:58 +08:00:     '  try {\n' +
2020-01-06 16:58 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 16:58 +08:00:     '      url: HOST + url,\n' +
2020-01-06 16:58 +08:00:     '      method,\n' +
2020-01-06 16:58 +08:00:     '      data\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '    const res = response.data;\n' +
2020-01-06 16:58 +08:00:     '    return res;\n' +
2020-01-06 16:58 +08:00:     '  } catch (e) {\n' +
2020-01-06 16:58 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '    Taro.showToast({\n' +
2020-01-06 16:58 +08:00:     '      title: "加载失败，请查看网络环境",\n' +
2020-01-06 16:58 +08:00:     '      icon: "none"\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '  }\n' +
2020-01-06 16:58 +08:00:     '}\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '简单介绍一下～\n' +
2020-01-06 16:58 +08:00:     '- 暴露出url, method, data 基本可以满足整个项目所有的request请求\n' +
2020-01-06 16:58 +08:00:     '- 设置统一的域名，方便项目由前期的测试域名迁移到生产环境下的域名，如果有多个域名下请求的话，便可以新建一个配置文件，使得更改更方便。\n' +
2020-01-06 16:58 +08:00:     '- 统一的在request请求中加入loading效果，做到网速慢的情况有一定的反馈，省的每次请求时都需要手动加上。\n' +
2020-01-06 16:58 +08:00:     '- 返回一个promise对象，在其他文件引用的时候可以通过.then来处理请求之后的逻辑。\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '#### redux中封装创建action的函数\n' +
2020-01-06 16:58 +08:00:     'show the code !\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:58 +08:00:     'import { HOST } from "./config";\n' +
2020-01-06 16:58 +08:00:     'const createActionSucess = (TYPE, data) => {\n' +
2020-01-06 16:58 +08:00:     '  return {\n' +
2020-01-06 16:58 +08:00:     '    type: TYPE,\n' +
2020-01-06 16:58 +08:00:     '    payload: data\n' +
2020-01-06 16:58 +08:00:     '  };\n' +
2020-01-06 16:58 +08:00:     '};\n' +
2020-01-06 16:58 +08:00:     'const createActionFail = data => {\n' +
2020-01-06 16:58 +08:00:     '  return {\n' +
2020-01-06 16:58 +08:00:     '    type: "GET_FAIL",\n' +
2020-01-06 16:58 +08:00:     '    payload: data\n' +
2020-01-06 16:58 +08:00:     '  };\n' +
2020-01-06 16:58 +08:00:     '};\n' +
2020-01-06 16:58 +08:00:     'export default function fetchData(option, TYPE) {\n' +
2020-01-06 16:58 +08:00:     '  return async dispatch => {\n' +
2020-01-06 16:58 +08:00:     '    Taro.showLoading({\n' +
2020-01-06 16:58 +08:00:     '      title: "loading..."\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '    const response = await Taro.request({\n' +
2020-01-06 16:58 +08:00:     '      url: HOST + option.url,\n' +
2020-01-06 16:58 +08:00:     '      method: option.method || "GET",\n' +
2020-01-06 16:58 +08:00:     '      data: option.data || ""\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '    const res = response.data;\n' +
2020-01-06 16:58 +08:00:     '    if (res.code === 0) {\n' +
2020-01-06 16:58 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '      dispatch(createActionSucess(TYPE, res.data));\n' +
2020-01-06 16:58 +08:00:     '    } else {\n' +
2020-01-06 16:58 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '      dispatch(createActionFail(res.data));\n' +
2020-01-06 16:58 +08:00:     '    }\n' +
2020-01-06 16:58 +08:00:     '    return res;\n' +
2020-01-06 16:58 +08:00:     '  };\n' +
2020-01-06 16:58 +08:00:     '}\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '具体分析在另一篇博文中有详细介绍。\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '### 项目中遇到的困难\n' +
2020-01-06 16:58 +08:00:     '- 小程序无法获取用户微信好友，但是产品同学觉得微信好友pk是一个非常重要的事情，那怎么才能获取微信好友呢？\n' +
2020-01-06 16:58 +08:00:     '这里和后端同学讨论了一段时间，最终想到的解决方案是通过用户分享小程序的url上携带用户标识，在新用户点击加入额小程序完成登陆操作之后立即获取该用户以及源用户的id，将其发送到后端，后端建立好友关系网，从而实现小程序内部好友的建立。\n' +
2020-01-06 16:58 +08:00:     '**并且此方法依赖于用户的主动分享，所以也不算上打扰用户或者窥探用户隐私啦～～并且在小程序内部已有相关的引导说明**\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '首先在页面中携带用户标识参数\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '  onShareAppMessage = res => {\n' +
2020-01-06 16:58 +08:00:     '    return {\n' +
2020-01-06 16:58 +08:00:     '      title: "小程序标题",\n' +
2020-01-06 16:58 +08:00:     '      path: `/pages/index/index?shareId=${myUserId}`\n' +
2020-01-06 16:58 +08:00:     '    };\n' +
2020-01-06 16:58 +08:00:     '  };\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '然后在新用户登陆的时候调用写好的“添加好友”函数进行判断以及处理\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:58 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 16:58 +08:00:     'export function addUserRelation(userOne, userTwo) {\n' +
2020-01-06 16:58 +08:00:     '  console.log("进入addUser收到的两个user", userOne, userTwo);\n' +
2020-01-06 16:58 +08:00:     '  if (userOne != 0 && userTwo != 0) {\n' +
2020-01-06 16:58 +08:00:     '    const data = {\n' +
2020-01-06 16:58 +08:00:     '      userOne,\n' +
2020-01-06 16:58 +08:00:     '      userTwo\n' +
2020-01-06 16:58 +08:00:     '    };\n' +
2020-01-06 16:58 +08:00:     '    myApi("/updateuserrelationship", "POST", data).then(res => {\n' +
2020-01-06 16:58 +08:00:     '      if (res.code === 0) {\n' +
2020-01-06 16:58 +08:00:     '        console.log("添加成功");\n' +
2020-01-06 16:58 +08:00:     '      }\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '  }\n' +
2020-01-06 16:58 +08:00:     '}\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '- 产品中间经历了一次大的迭代，登陆策略上都出现了比较大的变化，但是由于开发版，体验版，正式版三个版本共用一个缓存，又由于登陆策略的特殊性（这个就不细说啦，详见上个问题），版本更替测试的时候，第一版用户使用的依然是第一版的数据缓存，用户id分配便出现两个版本的混乱，如何解决呢？\n' +
2020-01-06 16:58 +08:00:     '其实这个也不算是什么大问题，主要问题的起源来自版本更新的时候涉及登录策略的改变（这个是由于上个问题导致的，即在登录过程中需建立好友关系网），再加上两个版本的开发版体验版正式版全部共用一个缓存！！\n' +
2020-01-06 16:58 +08:00:     '当然这个问题在最后也得到了完美的解决，即在登录函数中添加一个对version的维护，使得第一版中各个版本的用户更新storage的内容\n' +
2020-01-06 16:58 +08:00:     '**这里要注意，由于项目的特殊性，和小程序的版本更新api想要解决的不是同一个问题，这个项目最关键的主要是开发版体验版正式版共用一个缓存导致的，而非小程序迭代更新导致的，故无法直接通过官方的api来解决**\n' +
2020-01-06 16:58 +08:00:     '结合上个问题，可以看到最终的登录代码是这样的\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     'import Taro from "@tarojs/taro";\n' +
2020-01-06 16:58 +08:00:     'import myApi from "../service/api";\n' +
2020-01-06 16:58 +08:00:     'import { addUserRelation } from "./addUserRelation";\n' +
2020-01-06 16:58 +08:00:     'const againLogin = shareId => {\n' +
2020-01-06 16:58 +08:00:     '  console.log("进入againLogin");\n' +
2020-01-06 16:58 +08:00:     '  Taro.login().then(res => {\n' +
2020-01-06 16:58 +08:00:     '    if (res.code) {\n' +
2020-01-06 16:58 +08:00: s.code;\n' +
2020-01-06 16:58 +08:00:     '      Taro.getUserInfo()\n' +
2020-01-06 16:58 +08:00:     '        .then(userInfoRes => {\n' +
2020-01-06 16:58 +08:00:     '          const data = {\n' +
2020-01-06 16:58 +08:00:     '            code: userCode,\n' +
2020-01-06 16:58 +08:00:     '            iv: userInfoRes.iv,\n' +
2020-01-06 16:58 +08:00:     '            encryptedData: userInfoRes.encryptedData\n' +
2020-01-06 16:58 +08:00:     '          };\n' +
2020-01-06 16:58 +08:00:     '          myApi("/login", "POST", data).then(loginRes => {\n' +
2020-01-06 16:58 +08:00:     '            if (loginRes.code === 0) {\n' +
2020-01-06 16:58 +08:00:     '              console.log("重新登陆成功");\n' +
2020-01-06 16:58 +08:00:     '              Taro.setStorageSync("login", {\n' +
2020-01-06 16:58 +08:00:     '                userId: loginRes.data.userId,\n' +
2020-01-06 16:58 +08:00:     '                openId: loginRes.data.openId,\n' +
2020-01-06 16:58 +08:00:     '                session_key: loginRes.data.session_key\n' +
2020-01-06 16:58 +08:00:     '              });\n' +
2020-01-06 16:58 +08:00:     '              Taro.setStorageSync("version", {\n' +
2020-01-06 16:58 +08:00:     '                ver: "2.1"\n' +
2020-01-06 16:58 +08:00:     '              });\n' +
2020-01-06 16:58 +08:00:     '              if (shareId) {\n' +
2020-01-06 16:58 +08:00:     '                addUserRelation(shareId, loginRes.data.userId);\n' +
2020-01-06 16:58 +08:00:     '              }\n' +
2020-01-06 16:58 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '              Taro.switchTab({\n' +
2020-01-06 16:58 +08:00:     '                url: "/pages/index/index"\n' +
2020-01-06 16:58 +08:00:     '              });\n' +
2020-01-06 16:58 +08:00:     '            } else {\n' +
2020-01-06 16:58 +08:00:     '              Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '              Taro.showToast({\n' +
2020-01-06 16:58 +08:00:     '                title: "登录失败，请查看网络环境",\n' +
2020-01-06 16:58 +08:00:     '                icon: "none"\n' +
2020-01-06 16:58 +08:00:     '              });\n' +
2020-01-06 16:58 +08:00:     '            }\n' +
2020-01-06 16:58 +08:00:     '          });\n' +
2020-01-06 16:58 +08:00:     '        })\n' +
2020-01-06 16:58 +08:00:     '        .catch(e => {\n' +
2020-01-06 16:58 +08:00:     '          Taro.redirectTo({\n' +
2020-01-06 16:58 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:58 +08:00:     '          });\n' +
2020-01-06 16:58 +08:00:     '        });\n' +
2020-01-06 16:58 +08:00:     '    } else {\n' +
2020-01-06 16:58 +08:00:     '      Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '      Taro.showToast({\n' +
2020-01-06 16:58 +08:00:     '        title: "登录失败，请检查网络环境",\n' +
2020-01-06 16:58 +08:00:     '        icon: "none"\n' +
2020-01-06 16:58 +08:00:     '      });\n' +
2020-01-06 16:58 +08:00:     '    }\n' +
2020-01-06 16:58 +08:00:     '  });\n' +
2020-01-06 16:58 +08:00:     '};\n' +
2020-01-06 16:58 +08:00:     'export default function checkToLogin(shareId = 0) {\n' +
2020-01-06 16:58 +08:00:     '  Taro.showLoading({\n' +
2020-01-06 16:58 +08:00:     '    title: "loading...",\n' +
2020-01-06 16:58 +08:00:     '    icon: "loading"\n' +
2020-01-06 16:58 +08:00:     '  });\n' +
2020-01-06 16:58 +08:00:     '  const version = Taro.getStorageSync("version") || null;\n' +
2020-01-06 16:58 +08:00:     '  if (!version) {\n' +
2020-01-06 16:58 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '    console.log("version", version);\n' +
2020-01-06 16:58 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 16:58 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '  } else if (version.ver !== "2.1") {\n' +
2020-01-06 16:58 +08:00:     '    //手动在缓存中维护一个版本号，解决小程序的版本缓存问题\n' +
2020-01-06 16:58 +08:00:     '    Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '    Taro.redirectTo({\n' +
2020-01-06 16:58 +08:00:     '      url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '  } else {\n' +
2020-01-06 16:58 +08:00:     '    Taro.checkSession({\n' +
2020-01-06 16:58 +08:00:     '      success: function() {\n' +
2020-01-06 16:58 +08:00:     '        const basicInfo = Taro.getStorageSync("basicInfo") || null;\n' +
2020-01-06 16:58 +08:00:     '        const loginInfo = Taro.getStorageSync("login") || null;\n' +
2020-01-06 16:58 +08:00:     '        if (!basicInfo || !loginInfo) {\n' +
2020-01-06 16:58 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '          Taro.navigateTo({\n' +
2020-01-06 16:58 +08:00:     '            url: `/pages/login/login?shareId=${shareId}`\n' +
2020-01-06 16:58 +08:00:     '          });\n' +
2020-01-06 16:58 +08:00:     '        } else {\n' +
2020-01-06 16:58 +08:00:     '          Taro.hideLoading();\n' +
2020-01-06 16:58 +08:00:     '          if (shareId) {\n' +
2020-01-06 16:58 +08:00:     '            const userId = Taro.getStorageSync("login").userId;\n' +
2020-01-06 16:58 +08:00:     '            addUserRelation(shareId, userId);\n' +
2020-01-06 16:58 +08:00:     '          }\n' +
2020-01-06 16:58 +08:00:     '        }\n' +
2020-01-06 16:58 +08:00:     '      },\n' +
2020-01-06 16:58 +08:00:     '      fail: function() {\n' +
2020-01-06 16:58 +08:00:     '        console.log("登录态过期");\n' +
2020-01-06 16:58 +08:00:     '        againLogin(shareId);\n' +
2020-01-06 16:58 +08:00:     '      }\n' +
2020-01-06 16:58 +08:00:     '    });\n' +
2020-01-06 16:58 +08:00:     '  }\n' +
2020-01-06 16:58 +08:00:     '}\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '-  再谈一下利用redux方便的实现不同组件间数据的联动\n' +
2020-01-06 16:58 +08:00:     '\n' +
2020-01-06 16:58 +08:00:     '首先将redux状态树绑定到组件内部\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '@connect(\n' +
2020-01-06 16:58 +08:00:     '  ({ classInfo, cmtInfo }) => ({ classInfo, cmtInfo }),\n' +
2020-01-06 16:58 +08:00:     '  dispatch => ({\n' +
2020-01-06 16:58 +08:00:     '    getClassMsg(data) {\n' +
2020-01-06 16:58 +08:00:     '      return dispatch(getClassMsg(data));\n' +
2020-01-06 16:58 +08:00:     '    },\n' +
2020-01-06 16:58 +08:00:     '    ajaxGetUserClass(userId) {\n' +
2020-01-06 16:58 +08:00:     '      return dispatch(ajaxGetUserClass(userId));\n' +
2020-01-06 16:58 +08:00:     '    }\n' +
2020-01-06 16:58 +08:00:     '  })\n' +
2020-01-06 16:58 +08:00:     ')\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '然后需要在componentDidUpdate周期函数内对状态树进行监听，并发送请求更新状态\n' +
2020-01-06 16:58 +08:00:     '```\n' +
2020-01-06 16:58 +08:00:     '  componentDidUpdate(prevProps) {\n' +
2020-01-06 16:58 +08:00:     '    const { clazzId } = this.$router.params;\n' +
2020-01-06 16:58 +08:00:     '    if (this.props.classInfo.userClassId != prevProps.classInfo.userClassId) {\n' +
2020-01-06 16:58 +08:00:     '      this.checkIsAdded();\n' +
2020-01-06 16:58 +08:00:     '      this.getClassMessage(clazzId).then(res => {\n' +
2020-01-06 16:58 +08:00:     '        if (res.code === 0) {\n' +
2020-01-06 16:58 +08:00:     '          this.setState({\n' +
2020-01-06 16:58 +08:00:     '            isPunched: res.data.isPunchCard ? 1 : 0,\n' +
2020-01-06 16:58 +08:00:     '            classMsgState: res.data\n' +
2020-01-06 16:58 +08:00:     '          });\n' +
2020-01-06 16:58 +08:00:     '        }\n' +
2020-01-06 16:58 +08:00:     '      });\n' +
2020-01-06 16:58 +08:00:     '    }\n' +
2020-01-06 16:58 +08:00:     ' }\n' +
2020-01-06 16:58 +08:00:     '```',
2020-01-06 16:58 +08:00:   updatedAt: '2020-01-06 16:01',
2020-01-06 16:58 +08:00:   tags: [ 'vue', 'react', 'ng' ]
2020-01-06 16:58 +08:00: }
2020-01-06 16:58 +08:00:   --> GET /api/v1/article/138 200 69ms 10.47kb
